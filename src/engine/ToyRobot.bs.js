// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as $$Array from "bs-platform/lib/es6/array.js";
import * as Block from "bs-platform/lib/es6/block.js";
import * as Belt_Array from "bs-platform/lib/es6/belt_Array.js";
import * as Caml_array from "bs-platform/lib/es6/caml_array.js";
import * as Belt_Option from "bs-platform/lib/es6/belt_Option.js";
import * as Caml_format from "bs-platform/lib/es6/caml_format.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as Caml_builtin_exceptions from "bs-platform/lib/es6/caml_builtin_exceptions.js";

function make(east, north, $staropt$star, param) {
  var direction = $staropt$star !== undefined ? $staropt$star : /* NORTH */0;
  return {
          east: east,
          north: north,
          direction: direction
        };
}

function moveEast(robot) {
  return {
          east: robot.east + 1 | 0,
          north: robot.north,
          direction: robot.direction
        };
}

function moveWest(robot) {
  return {
          east: robot.east - 1 | 0,
          north: robot.north,
          direction: robot.direction
        };
}

function moveNorth(robot) {
  return {
          east: robot.east,
          north: robot.north + 1 | 0,
          direction: robot.direction
        };
}

function moveSouth(robot) {
  return {
          east: robot.east,
          north: robot.north - 1 | 0,
          direction: robot.direction
        };
}

function move(robot) {
  var match = robot.direction;
  switch (match) {
    case /* NORTH */0 :
        return moveNorth(robot);
    case /* SOUTH */1 :
        return moveSouth(robot);
    case /* EAST */2 :
        return moveEast(robot);
    case /* WEST */3 :
        return moveWest(robot);
    
  }
}

function nextMove(robot, numberOfSpaces) {
  var match = robot.direction;
  switch (match) {
    case /* NORTH */0 :
        return /* tuple */[
                robot.east,
                robot.north + numberOfSpaces | 0
              ];
    case /* SOUTH */1 :
        return /* tuple */[
                robot.east,
                robot.north - numberOfSpaces | 0
              ];
    case /* EAST */2 :
        return /* tuple */[
                robot.east + numberOfSpaces | 0,
                robot.north
              ];
    case /* WEST */3 :
        return /* tuple */[
                robot.east - numberOfSpaces | 0,
                robot.north
              ];
    
  }
}

function turnLeft(robot) {
  var match = robot.direction;
  var newDirection;
  switch (match) {
    case /* NORTH */0 :
        newDirection = /* WEST */3;
        break;
    case /* SOUTH */1 :
        newDirection = /* EAST */2;
        break;
    case /* EAST */2 :
        newDirection = /* NORTH */0;
        break;
    case /* WEST */3 :
        newDirection = /* SOUTH */1;
        break;
    
  }
  return {
          east: robot.east,
          north: robot.north,
          direction: newDirection
        };
}

function turnRight(robot) {
  var match = robot.direction;
  var newDirection;
  switch (match) {
    case /* NORTH */0 :
        newDirection = /* EAST */2;
        break;
    case /* SOUTH */1 :
        newDirection = /* WEST */3;
        break;
    case /* EAST */2 :
        newDirection = /* SOUTH */1;
        break;
    case /* WEST */3 :
        newDirection = /* NORTH */0;
        break;
    
  }
  return {
          east: robot.east,
          north: robot.north,
          direction: newDirection
        };
}

function directionOfString(string) {
  switch (string) {
    case "EAST" :
        return /* EAST */2;
    case "NORTH" :
        return /* NORTH */0;
    case "SOUTH" :
        return /* SOUTH */1;
    case "WEST" :
        return /* WEST */3;
    default:
      throw Caml_builtin_exceptions.not_found;
  }
}

function stringOfDirection(direction) {
  switch (direction) {
    case /* NORTH */0 :
        return "NORTH";
    case /* SOUTH */1 :
        return "SOUTH";
    case /* EAST */2 :
        return "EAST";
    case /* WEST */3 :
        return "WEST";
    
  }
}

function report(robot) {
  var east = String(robot.east);
  var north = String(robot.north);
  var direction = stringOfDirection(robot.direction);
  return "" + (String(east) + ("," + (String(north) + ("," + (String(direction) + "")))));
}

var Robot = {
  make: make,
  moveEast: moveEast,
  moveWest: moveWest,
  moveNorth: moveNorth,
  moveSouth: moveSouth,
  move: move,
  nextMove: nextMove,
  turnLeft: turnLeft,
  turnRight: turnRight,
  directionOfString: directionOfString,
  stringOfDirection: stringOfDirection,
  report: report
};

function make$1(width, length) {
  return {
          width: width,
          length: length
        };
}

function validLocation(table, east, north) {
  if (east >= 0 && east < table.width && north >= 0) {
    return north < table.length;
  } else {
    return false;
  }
}

var Table = {
  make: make$1,
  validLocation: validLocation
};

function make$2(table) {
  return {
          table: table,
          robot: undefined
        };
}

function place(simulator, east, north, facing) {
  if (validLocation(simulator.table, east, north)) {
    var newRobot = make(east, north, facing, /* () */0);
    return {
            table: simulator.table,
            robot: newRobot
          };
  } else {
    return simulator;
  }
}

function move$1(simulator, numberOfSpaces) {
  var newRobot = Belt_Option.map(simulator.robot, (function (robot) {
          var match = nextMove(robot, numberOfSpaces);
          if (validLocation(simulator.table, match[0], match[1])) {
            return Belt_Array.reduce(Belt_Array.makeBy(numberOfSpaces, (function (i) {
                              return i;
                            })), robot, (function (current, param) {
                          return move(current);
                        }));
          } else {
            return robot;
          }
        }));
  return {
          table: simulator.table,
          robot: newRobot
        };
}

function turnLeft$1(simulator) {
  var newRobot = Belt_Option.map(simulator.robot, turnLeft);
  return {
          table: simulator.table,
          robot: newRobot
        };
}

function turnRight$1(simulator) {
  var newRobot = Belt_Option.map(simulator.robot, turnRight);
  return {
          table: simulator.table,
          robot: newRobot
        };
}

function report$1(simulator) {
  return Belt_Option.map(simulator.robot, report);
}

var Simulator = {
  make: make$2,
  place: place,
  move: move$1,
  turnLeft: turnLeft$1,
  turnRight: turnRight$1,
  report: report$1
};

var Utilities = { };

function asPlace(string) {
  return Belt_Option.map(Caml_option.null_to_opt(string.match((/PLACE (\d+),(\d+),(EAST|WEST|NORTH|SOUTH)/))), (function (matches) {
                return /* PLACE */Block.__(0, [
                          Caml_format.caml_int_of_string(Caml_array.caml_array_get(matches, 1)),
                          Caml_format.caml_int_of_string(Caml_array.caml_array_get(matches, 2)),
                          directionOfString(Caml_array.caml_array_get(matches, 3))
                        ]);
              }));
}

function run(command) {
  var val;
  var val$1;
  try {
    val = command;
    val$1 = asPlace(command);
  }
  catch (exn){
    return /* INVALID */Block.__(2, [command]);
  }
  switch (val) {
    case "LEFT" :
        return /* LEFT */0;
    case "MOVE" :
        return /* MOVE */Block.__(1, [1]);
    case "REPORT" :
        return /* REPORT */2;
    case "RIGHT" :
        return /* RIGHT */1;
    default:
      if (val$1 !== undefined) {
        return val$1;
      } else {
        return /* INVALID */Block.__(2, [command]);
      }
  }
}

var Command = {
  asPlace: asPlace,
  run: run
};

function splitByLines(text) {
  return Belt_Array.reduce(text.split("\n"), /* array */[], (function (current, result) {
                var stripped = result.trim();
                if (stripped === "") {
                  return current;
                } else {
                  return $$Array.append(current, /* array */[stripped]);
                }
              }));
}

function loadCommands(text) {
  return $$Array.map(run, splitByLines(text));
}

function runCommands(simulator, commands) {
  var report$2 = {
    contents: undefined
  };
  Belt_Array.reduce(commands, simulator, (function (current, command) {
          if (typeof command === "number") {
            switch (command) {
              case /* LEFT */0 :
                  return turnLeft$1(current);
              case /* RIGHT */1 :
                  return turnRight$1(current);
              case /* REPORT */2 :
                  report$2.contents = Belt_Option.map(current.robot, report);
                  return current;
              
            }
          } else {
            switch (command.tag | 0) {
              case /* PLACE */0 :
                  return place(current, command[0], command[1], command[2]);
              case /* MOVE */1 :
                  return move$1(current, command[0]);
              case /* INVALID */2 :
                  return current;
              
            }
          }
        }));
  return report$2.contents;
}

var CLI = {
  splitByLines: splitByLines,
  loadCommands: loadCommands,
  runCommands: runCommands
};

export {
  Robot ,
  Table ,
  Simulator ,
  Utilities ,
  Command ,
  CLI ,
  
}
/* No side effect */
